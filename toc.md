# Table of Contents

## [1 Preface](ch01.md#1-preface)
  + [1.1 Multitasking in Small Embedded Systems](ch01.md#11-multitasking-in-small-embedded-systems)
    + [1.1.1 About the FreeRTOS Kernel](ch01.md#111-about-the-freertos-kernel)
    + [1.1.2 Value Proposition](ch01.md#112-value-proposition)
    + [1.1.3 A Note About Terminology](ch01.md#113-a-note-about-terminology)
    + [1.1.4 Why Use an RTOS?](ch01.md#114-why-use-an-rtos)
    + [1.1.5 FreeRTOS Kernel Features](ch01.md#115-freertos-kernel-features)
    + [1.1.6 Licensing, and The FreeRTOS, OpenRTOS, and SafeRTOS Family](ch01.md#116-licensing-and-the-freertos-openrtos-and-safertos-family)
  + [1.2 Included Source Files and Projects](ch01.md#12-included-source-files-and-projects)
    + [1.2.1 Obtaining the Examples that Accompany this Book](ch01.md#121-obtaining-the-examples-that-accompany-this-book)

## [2 The FreeRTOS Kernel Distribution](ch02.md#2-the-freertos-kernel-distribution)
  + [2.1 Introduction](ch02.md#21-introduction)
  + [2.2 Understanding the FreeRTOS Distribution](ch02.md#22-understanding-the-freertos-distribution)
    + [2.2.1 Definition: FreeRTOS Port](ch02.md#221-definition-freertos-port)
    + [2.2.2 Building FreeRTOS](ch02.md#222-building-freertos)
    + [2.2.3 FreeRTOSConfig.h](ch02.md#223-freertosconfigh)
    + [2.2.4 Official Distributions](ch02.md#224-official-distributions)
    + [2.2.6 FreeRTOS Source Files Common to All Ports](ch02.md#226-freertos-source-files-common-to-all-ports)
    + [2.2.7 FreeRTOS Source Files Specific to a Port](ch02.md#227-freertos-source-files-specific-to-a-port)
    + [2.2.8 Include Paths](ch02.md#228-include-paths)
    + [2.2.9 Header Files](ch02.md#229-header-files)
  + [2.3 Demo Applications](ch02.md#23-demo-applications)
  + [2.4 Creating a FreeRTOS Project](ch02.md#24-creating-a-freertos-project)
    + [2.4.1 Adapting One of the Supplied Demo Projects](ch02.md#241-adapting-one-of-the-supplied-demo-projects)
    + [2.4.2 Creating a New Project from Scratch](ch02.md#242-creating-a-new-project-from-scratch)
  + [2.5 Data Types and Coding Style Guide](ch02.md#25-data-types-and-coding-style-guide)
    + [2.5.1 Data Types](ch02.md#251-data-types)
    + [2.5.2 Variable Names](ch02.md#252-variable-names)
    + [2.5.3 Function Names](ch02.md#253-function-names)
    + [2.5.4 Formatting](ch02.md#254-formatting)
    + [2.5.5 Macro Names](ch02.md#255-macro-names)
    + [2.5.6 Rationale for Excessive Type Casting](ch02.md#256-rationale-for-excessive-type-casting)

## [3 Heap Memory Management](ch03.md#3-heap-memory-management)
  + [3.1 Introduction](ch03.md#31-introduction)
    + [3.1.1 Prerequisites](ch03.md#311-prerequisites)
    + [3.1.2 Scope](ch03.md#312-scope)
    + [3.1.3 Switching Between Static and Dynamic Memory Allocation](ch03.md#313-switching-between-static-and-dynamic-memory-allocation)
    + [3.1.4 Using Dynamic Memory Allocation](ch03.md#314-using-dynamic-memory-allocation)
    + [3.1.5 Options for Dynamic Memory Allocation](ch03.md#315-options-for-dynamic-memory-allocation)
  + [3.2 Example Memory Allocation Schemes](ch03.md#32-example-memory-allocation-schemes)
    + [3.2.1 Heap\_1](ch03.md#321-heap_1)
    + [3.2.2 Heap\_2](ch03.md#322-heap_2)
    + [3.2.3 Heap\_3](ch03.md#323-heap_3)
    + [3.2.4 Heap\_4](ch03.md#324-heap_4)
    + [3.2.5 Heap\_5](ch03.md#325-heap_5)
    + [3.2.6 Initialising heap\_5: The vPortDefineHeapRegions() API Function](ch03.md#326-initialising-heap_5-the-vportdefineheapregions-api-function)
  + [3.3 Heap Related Utility Functions and Macros](ch03.md#33-heap-related-utility-functions-and-macros)
    + [3.3.1 Defining the Heap Start Address](ch03.md#331-defining-the-heap-start-address)
    + [3.3.2 The xPortGetFreeHeapSize() API Function](ch03.md#332-the-xportgetfreeheapsize-api-function)
    + [3.3.3 The xPortGetMinimumEverFreeHeapSize() API Function](ch03.md#333-the-xportgetminimumeverfreeheapsize-api-function)
    + [3.3.4 The vPortGetHeapStats() API Function](ch03.md#334-the-vportgetheapstats-api-function)
    + [3.3.5 Collecting Per-task Heap Usage Statistics](ch03.md#335-collecting-per-task-heap-usage-statistics)
    + [3.3.6 Malloc Failed Hook Functions](ch03.md#336-malloc-failed-hook-functions)
    + [3.3.7 Placing Task Stacks in Fast Memory](ch03.md#337-placing-task-stacks-in-fast-memory)
  + [3.4 Using Static Memory Allocation](ch03.md#34-using-static-memory-allocation)
    + [3.4.1 Enabling Static Memory Allocation](ch03.md#341-enabling-static-memory-allocation)
    + [3.4.2 Static Internal Kernel Memory](ch03.md#342-static-internal-kernel-memory)
      + [3.4.2.1 vApplicationGetTimerTaskMemory](ch03.md#3421-vapplicationgettimertaskmemory)
      + [3.4.2.2 vApplicationGetIdleTaskMemory](ch03.md#3422-vapplicationgetidletaskmemory)

## [4 Task Management](ch04.md#4-task-management)
  + [4.1 Introduction](ch04.md#41-introduction)
    + [4.1.1 Scope](ch04.md#411-scope)
  + [4.2 Task Functions](ch04.md#42-task-functions)
  + [4.3 Top Level Task States](ch04.md#43-top-level-task-states)
  + [4.4 Task Creation](ch04.md#44-task-creation)
    + [4.4.1 The xTaskCreate() API Function](ch04.md#441-the-xtaskcreate-api-function)
  + [4.5 Task Priorities](ch04.md#45-task-priorities)
    + [Generic Scheduler](ch04.md#451-generic-scheduler)
    + [Architecture-Optimized Scheduler](ch04.md#452-architecture-optimized-scheduler)
  + [4.6 Time Measurement and the Tick Interrupt](ch04.md#46-time-measurement-and-the-tick-interrupt)
  + [4.7 Expanding the *Not Running* State](ch04.md#47-expanding-the-not-running-state)
    + [4.7.1 The *Blocked* State](ch04.md#471-the-blocked-state)
    + [4.7.2 The *Suspended* State](ch04.md#472-the-suspended-state)
    + [4.7.3 The Ready State](ch04.md#473-the-ready-state)
    + [4.7.4 Completing the State Transition Diagram](ch04.md#474-completing-the-state-transition-diagram)
    + [4.7.5 The vTaskDelayUntil() API Function](ch04.md#475-the-vtaskdelayuntil-api-function)
  + [4.8 The Idle Task and the Idle Task Hook](ch04.md#48-the-idle-task-and-the-idle-task-hook)
    + [4.8.1 Idle Task Hook Functions](ch04.md#481-idle-task-hook-functions)
    + [4.8.2 Limitations on the Implementation of Idle Task Hook Functions](ch04.md#482-limitations-on-the-implementation-of-idle-task-hook-functions)
  + [4.9 Changing the Priority of a Task](ch04.md#49-changing-the-priority-of-a-task)
    + [4.9.1 The vTaskPrioritySet() API Function](ch04.md#491-the-vtaskpriorityset-api-function)
    + [4.9.2 The uxTaskPriorityGet() API Function](ch04.md#492-the-uxtaskpriorityget-api-function)
  + [4.10 Deleting a Task](ch04.md#410-deleting-a-task)
    + [4.10.1 The vTaskDelete() API Function](ch04.md#4101-the-vtaskdelete-api-function)
  + [4.11 Thread Local Storage and Reentrancy](ch04.md#411-thread-local-storage-and-reentrancy)
    + [4.11.1 C Runtime Thread Local Storage Implementations](ch04.md#4111-c-runtime-thread-local-storage-implementations)
    + [4.11.2 Custom C Runtime Thread Local Storage](ch04.md#4112-custom-c-runtime-thread-local-storage)
    + [4.11.3 Application Thread Local Storage](ch04.md#4113-application-thread-local-storage)
  + [4.12 Scheduling Algorithms](ch04.md#412-scheduling-algorithms)
    + [4.12.1 A Recap of Task States and Events](ch04.md#4121-a-recap-of-task-states-and-events)
    + [4.12.2 Selecting the Scheduling Algorithm](ch04.md#4122-selecting-the-scheduling-algorithm)
    + [4.12.3 Prioritized Preemptive Scheduling with Time Slicing](ch04.md#4123-prioritized-preemptive-scheduling-with-time-slicing)
    + [4.12.4 Prioritized Preemptive Scheduling without Time Slicing](ch04.md#4124-prioritized-preemptive-scheduling-without-time-slicing)
    + [4.12.5 Cooperative Scheduling](ch04.md#4125-cooperative-scheduling)

## [5 Queue Management](ch05.md#5-queue-management)
  + [5.1 Introduction](ch05.md#51-introduction)
    + [5.1.1 Scope](ch05.md#511-scope)
  + [5.2 Characteristics of a Queue](ch05.md#52-characteristics-of-a-queue)
    + [5.2.1 Data Storage](ch05.md#521-data-storage)
    + [5.2.2 Access by Multiple Tasks](ch05.md#522-access-by-multiple-tasks)
    + [5.2.3 Blocking on Queue Reads](ch05.md#523-blocking-on-queue-reads)
    + [5.2.4 Blocking on Queue Writes](ch05.md#524-blocking-on-queue-writes)
    + [5.2.5 Blocking on Multiple Queues](ch05.md#525-blocking-on-multiple-queues)
    + [5.2.6 Creating Queues: Statically Allocated and Dynamically Allocated Queues](ch05.md#526-creating-queues-statically-allocated-and-dynamically-allocated-queues)
  + [5.3 Using a Queue](ch05.md#53-using-a-queue)
    + [5.3.1 The xQueueCreate() API Function](ch05.md#531-the-xqueuecreate-api-function)
    + [5.3.2 The xQueueSendToBack() and xQueueSendToFront() API Functions](ch05.md#532-the-xqueuesendtoback-and-xqueuesendtofront-api-functions)
    + [5.3.3 The xQueueReceive() API Function](ch05.md#533-the-xqueuereceive-api-function)
    + [5.3.4 The uxQueueMessagesWaiting() API Function](ch05.md#534-the-uxqueuemessageswaiting-api-function)
  + [5.4 Receiving Data From Multiple Sources](ch05.md#54-receiving-data-from-multiple-sources)
  + [5.5 Working with Large or Variable Sized Data](ch05.md#55-working-with-large-or-variable-sized-data)
    + [5.5.1 Queuing Pointers](ch05.md#551-queuing-pointers)
    + [5.5.2 Using a Queue to Send Different Types and Lengths of Data[^9]](ch05.md#552-using-a-queue-to-send-different-types-and-lengths-of-data9)
  + [5.6 Receiving From Multiple Queues](ch05.md#56-receiving-from-multiple-queues)
    + [5.6.1 Queue Sets](ch05.md#561-queue-sets)
    + [5.6.2 The xQueueCreateSet() API Function](ch05.md#562-the-xqueuecreateset-api-function)
    + [5.6.3 The xQueueAddToSet() API Function](ch05.md#563-the-xqueueaddtoset-api-function)
    + [5.6.4 The xQueueSelectFromSet() API Function](ch05.md#564-the-xqueueselectfromset-api-function)
    + [5.6.5 More Realistic Queue Set Use Cases](ch05.md#565-more-realistic-queue-set-use-cases)
  + [5.7 Using a Queue to Create a Mailbox](ch05.md#57-using-a-queue-to-create-a-mailbox)
    + [5.7.1 The xQueueOverwrite() API Function](ch05.md#571-the-xqueueoverwrite-api-function)
    + [5.7.2 The xQueuePeek() API Function](ch05.md#572-the-xqueuepeek-api-function)

## [6 Software Timer Management](ch06.md#6-software-timer-management)
  + [6.1 Chapter Introduction and Scope](ch06.md#61-chapter-introduction-and-scope)
    + [6.1.1 Scope](ch06.md#611-scope)
  + [6.2 Software Timer Callback Functions](ch06.md#62-software-timer-callback-functions)
  + [6.3 Attributes and States of a Software Timer](ch06.md#63-attributes-and-states-of-a-software-timer)
    + [6.3.1 Period of a Software Timer](ch06.md#631-period-of-a-software-timer)
    + [6.3.2 One-shot and Auto-reload Timers](ch06.md#632-one-shot-and-auto-reload-timers)
    + [6.3.3 Software Timer States](ch06.md#633-software-timer-states)
  + [6.4 The Context of a Software Timer](ch06.md#64-the-context-of-a-software-timer)
    + [6.4.1 The RTOS Daemon (Timer Service) Task](ch06.md#641-the-rtos-daemon-timer-service-task)
    + [6.4.2 The Timer Command Queue](ch06.md#642-the-timer-command-queue)
    + [6.4.3 Daemon Task Scheduling](ch06.md#643-daemon-task-scheduling)
  + [6.5 Creating and Starting a Software Timer](ch06.md#65-creating-and-starting-a-software-timer)
    + [6.5.1 The xTimerCreate() API Function](ch06.md#651-the-xtimercreate-api-function)
    + [6.5.2 The xTimerStart() API Function](ch06.md#652-the-xtimerstart-api-function)
  + [6.6 The Timer ID](ch06.md#66-the-timer-id)
    + [6.6.1 The vTimerSetTimerID() API Function](ch06.md#661-the-vtimersettimerid-api-function)
    + [6.6.2 The pvTimerGetTimerID() API Function](ch06.md#662-the-pvtimergettimerid-api-function)
  + [6.7 Changing the Period of a Timer](ch06.md#67-changing-the-period-of-a-timer)
    + [6.7.1 The xTimerChangePeriod() API Function](ch06.md#671-the-xtimerchangeperiod-api-function)
  + [6.8 Resetting a Software Timer](ch06.md#68-resetting-a-software-timer)
    + [6.8.1 The xTimerReset() API Function](ch06.md#681-the-xtimerreset-api-function)

## [7 Interrupt Management](ch07.md#7-interrupt-management)
  + [7.1 Introduction](ch07.md#71-introduction)
    + [7.1.1 Events](ch07.md#711-events)
    + [7.1.2 Scope](ch07.md#712-scope)
  + [7.2 Using the FreeRTOS API from an ISR](ch07.md#72-using-the-freertos-api-from-an-isr)
    + [7.2.1 The Interrupt Safe API](ch07.md#721-the-interrupt-safe-api)
    + [7.2.2 The Benefits of Using a Separate Interrupt Safe API](ch07.md#722-the-benefits-of-using-a-separate-interrupt-safe-api)
    + [7.2.3 The Disadvantages of Using a Separate, Interrupt Safe API](ch07.md#723-the-disadvantages-of-using-a-separate-interrupt-safe-api)
    + [7.2.4 The xHigherPriorityTaskWoken Parameter](ch07.md#724-the-xhigherprioritytaskwoken-parameter)
    + [7.2.5 The portYIELD\_FROM\_ISR() and portEND\_SWITCHING\_ISR() Macros](ch07.md#725-the-portyield_from_isr-and-portend_switching_isr-macros)
  + [7.3 Deferred Interrupt Processing](ch07.md#73-deferred-interrupt-processing)
  + [7.4 Binary Semaphores Used for Synchronization](ch07.md#74-binary-semaphores-used-for-synchronization)
    + [7.4.1 The xSemaphoreCreateBinary() API Function](ch07.md#741-the-xsemaphorecreatebinary-api-function)
    + [7.4.2 The xSemaphoreTake() API Function](ch07.md#742-the-xsemaphoretake-api-function)
    + [7.4.3 The xSemaphoreGiveFromISR() API Function](ch07.md#743-the-xsemaphoregivefromisr-api-function)
    + [7.4.4 Improving the Implementation of the Task Used in Example 7.1](ch07.md#744-improving-the-implementation-of-the-task-used-in-example-71)
  + [7.5 Counting Semaphores](ch07.md#75-counting-semaphores)
    + [7.5.1 The xSemaphoreCreateCounting() API Function](ch07.md#751-the-xsemaphorecreatecounting-api-function)
  + [7.6 Deferring Work to the RTOS Daemon Task](ch07.md#76-deferring-work-to-the-rtos-daemon-task)
    + [7.6.1 The xTimerPendFunctionCallFromISR() API Function](ch07.md#761-the-xtimerpendfunctioncallfromisr-api-function)
  + [7.7 Using Queues within an Interrupt Service Routine](ch07.md#77-using-queues-within-an-interrupt-service-routine)
    + [7.7.1 The xQueueSendToFrontFromISR() and xQueueSendToBackFromISR() API Functions](ch07.md#771-the-xqueuesendtofrontfromisr-and-xqueuesendtobackfromisr-api-functions)
    + [7.7.2 Considerations When Using a Queue From an ISR](ch07.md#772-considerations-when-using-a-queue-from-an-isr)
  + [7.8 Interrupt Nesting](ch07.md#78-interrupt-nesting)
    + [7.8.1 A Note to ARM Cortex-M[^22] and ARM GIC Users](ch07.md#781-a-note-to-arm-cortex-m22-and-arm-gic-users)

## [8 Resource Management](ch08.md#8-resource-management)
  + [8.1 Chapter Introduction and Scope](ch08.md#81-chapter-introduction-and-scope)
    + [8.1.1 Mutual Exclusion](ch08.md#811-mutual-exclusion)
    + [8.1.2 Scope](ch08.md#812-scope)
  + [8.2 Critical Sections and Suspending the Scheduler](ch08.md#82-critical-sections-and-suspending-the-scheduler)
    + [8.2.1 Basic Critical Sections](ch08.md#821-basic-critical-sections)
    + [8.2.2 Suspending (or Locking) the Scheduler](ch08.md#822-suspending-or-locking-the-scheduler)
    + [8.2.3 The vTaskSuspendAll() API Function](ch08.md#823-the-vtasksuspendall-api-function)
    + [8.2.4 The xTaskResumeAll() API Function](ch08.md#824-the-xtaskresumeall-api-function)
  + [8.3 Mutexes (and Binary Semaphores)](ch08.md#83-mutexes-and-binary-semaphores)
    + [8.3.1 The xSemaphoreCreateMutex() API Function](ch08.md#831-the-xsemaphorecreatemutex-api-function)
    + [8.3.2 Priority Inversion](ch08.md#832-priority-inversion)
    + [8.3.3 Priority Inheritance](ch08.md#833-priority-inheritance)
    + [8.3.4 Deadlock (or Deadly Embrace)](ch08.md#834-deadlock-or-deadly-embrace)
    + [8.3.5 Recursive Mutexes](ch08.md#835-recursive-mutexes)
    + [8.3.6 Mutexes and Task Scheduling](ch08.md#836-mutexes-and-task-scheduling)
  + [8.4 Gatekeeper Tasks](ch08.md#84-gatekeeper-tasks)
    + [8.4.1 Re-writing vPrintString() to use a gatekeeper task](ch08.md#841-re-writing-vprintstring-to-use-a-gatekeeper-task)

## [9 Event Groups](ch09.md#9-event-groups)
  + [9.1 Chapter Introduction and Scope](ch09.md#91-chapter-introduction-and-scope)
    + [9.1.1 Scope](ch09.md#911-scope)
  + [9.2 Characteristics of an Event Group](ch09.md#92-characteristics-of-an-event-group)
    + [9.2.1 Event Groups, Event Flags and Event Bits](ch09.md#921-event-groups-event-flags-and-event-bits)
    + [9.2.2 More About the EventBits\_t Data Type](ch09.md#922-more-about-the-eventbits_t-data-type)
    + [9.2.3 Access by Multiple Tasks](ch09.md#923-access-by-multiple-tasks)
    + [9.2.4 A Practical Example of Using an Event Group](ch09.md#924-a-practical-example-of-using-an-event-group)
  + [9.3 Event Management Using Event Groups](ch09.md#93-event-management-using-event-groups)
    + [9.3.1 The xEventGroupCreate() API Function](ch09.md#931-the-xeventgroupcreate-api-function)
    + [9.3.2 The xEventGroupSetBits() API Function](ch09.md#932-the-xeventgroupsetbits-api-function)
    + [9.3.3 The xEventGroupSetBitsFromISR() API Function](ch09.md#933-the-xeventgroupsetbitsfromisr-api-function)
    + [9.3.4 The xEventGroupWaitBits() API Function](ch09.md#934-the-xeventgroupwaitbits-api-function)
    + [9.3.5 The xEventGroupGetStaticBuffer() API Function](ch09.md#935-the-xeventgroupgetstaticbuffer-api-function)
  + [9.4 Task Synchronization Using an Event Group](ch09.md#94-task-synchronization-using-an-event-group)
    + [9.4.1 The xEventGroupSync() API Function](ch09.md#941-the-xeventgroupsync-api-function)

## [10 Task Notifications](ch10.md#10-task-notifications)
  + [10.1 Introduction](ch10.md#101-introduction)
    + [10.1.1 Communicating Through Intermediary Objects](ch10.md#1011-communicating-through-intermediary-objects)
    + [10.1.2 Task Notifications—Direct to Task Communication](ch10.md#1012-task-notificationsdirect-to-task-communication)
    + [10.1.3 Scope](ch10.md#1013-scope)
  + [10.2 Task Notifications; Benefits and Limitations](ch10.md#102-task-notifications-benefits-and-limitations)
    + [10.2.1 Performance Benefits of Task Notifications](ch10.md#1021-performance-benefits-of-task-notifications)
    + [10.2.2 RAM Footprint Benefits of Task Notifications](ch10.md#1022-ram-footprint-benefits-of-task-notifications)
    + [10.2.3 Limitations of Task Notifications](ch10.md#1023-limitations-of-task-notifications)
  + [10.3 Using Task Notifications](ch10.md#103-using-task-notifications)
    + [10.3.1 Task Notification API Options](ch10.md#1031-task-notification-api-options)
      + [10.3.1.1 The complete list of API functions <sup>27</sup>](ch10.md#10311-the-complete-list-of-api-functions-sup27sup)
    + [10.3.2 The xTaskNotifyGive() API Functions](ch10.md#1032-the-xtasknotifygive-api-functions)
    + [10.3.3 The vTaskNotifyGiveFromISR() API Function](ch10.md#1033-the-vtasknotifygivefromisr-api-function)
    + [10.3.4 The ulTaskNotifyTake() API Function](ch10.md#1034-the-ultasknotifytake-api-function)
    + [10.3.5 The xTaskNotify() and xTaskNotifyFromISR() API Functions](ch10.md#1035-the-xtasknotify-and-xtasknotifyfromisr-api-functions)
    + [10.3.6 The xTaskNotifyWait() API Function](ch10.md#1036-the-xtasknotifywait-api-function)
    + [10.3.7 Task Notifications Used in Peripheral Device Drivers: UART Example](ch10.md#1037-task-notifications-used-in-peripheral-device-drivers-uart-example)
    + [10.3.8 Task Notifications Used in Peripheral Device Drivers: ADC Example](ch10.md#1038-task-notifications-used-in-peripheral-device-drivers-adc-example)
    + [10.3.9 Task Notifications Used Directly Within an Application](ch10.md#1039-task-notifications-used-directly-within-an-application)

## [11 Low Power Support](ch11.md#11-low-power-support)
  + [11.1 Power Saving Introduction](ch11.md#111-power-saving-introduction)
  + [11.2 FreeRTOS Sleep Modes](ch11.md#112-freertos-sleep-modes)
  + [11.3 Functions and Enabling Built-in Tickless Idle Functionality](ch11.md#113-functions-and-enabling-built-in-tickless-idle-functionality)
    + [11.3.1 The portSUPPRESS\_TICKS\_AND\_SLEEP() Macro](ch11.md#1131-the-portsuppress_ticks_and_sleep-macro)
    + [11.3.2 The vPortSuppressTicksAndSleep Function](ch11.md#1132-the-vportsuppressticksandsleep-function)
    + [11.3.3 The eTaskConfirmSleepModeStatus Function](ch11.md#1133-the-etaskconfirmsleepmodestatus-function)
    + [11.3.4 The configPRE\_SLEEP\_PROCESSING configuration](ch11.md#1134-the-configpre_sleep_processing-configuration)
    + [11.3.5 The configPOST\_SLEEP\_PROCESSING configuration](ch11.md#1135-the-configpost_sleep_processing-configuration)
  + [11.4 Implementing portSUPPRESS\_TICKS\_AND\_SLEEP() Macro](ch11.md#114-implementing-portsuppress_ticks_and_sleep-macro)
  + [11.5 Idle Task Hook Function](ch11.md#115-idle-task-hook-function)

## [12 Developer Support](ch12.md#12-developer-support)
  + [12.1 Introduction ](ch12.md#121-introduction)
  + [12.2 configASSERT()](ch12.md#122-configassert)
    + [12.2.1 Example configASSERT() definitions](ch12.md#1221-example-configassert-definitions)
  + [12.3 Tracealyzer for FreeRTOS](ch12.md#123-tracealyzer-for-freertos)
  + [12.4 Debug Related Hook (Callback) Functions](ch12.md#124-debug-related-hook-callback-functions)
    + [12.4.1 Malloc failed hook](ch12.md#1241-malloc-failed-hook)
  + [12.5 Viewing Run-time and Task State Information](ch12.md#125-viewing-run-time-and-task-state-information)
    + [12.5.1 Task Run-Time Statistics](ch12.md#1251-task-run-time-statistics)
    + [12.5.2 The Run-Time Statistics Clock](ch12.md#1252-the-run-time-statistics-clock)
    + [12.5.3 Configuring an Application to Collect Run-Time Statistics](ch12.md#1253-configuring-an-application-to-collect-run-time-statistics)
    + [12.5.4 The uxTaskGetSystemState() API Function](ch12.md#1254-the-uxtaskgetsystemstate-api-function)
    + [12.5.5 The vTaskListTasks() Helper Function](ch12.md#1255-the-vtasklisttasks-helper-function)
    + [12.5.6 The vTaskGetRunTimeStatistics() Helper Function](ch12.md#1256-the-vtaskgetruntimestatistics-helper-function)
    + [12.5.7 Generating and Displaying Run-Time Statistics, a Worked Example](ch12.md#1257-generating-and-displaying-run-time-statistics-a-worked-example)
  + [12.6 Trace Hook Macros](ch12.md#126-trace-hook-macros)
    + [12.6.1 Available Trace Hook Macros](ch12.md#1261-available-trace-hook-macros)
    + [12.6.2 Defining Trace Hook Macros](ch12.md#1262-defining-trace-hook-macros)
    + [12.6.3 FreeRTOS Aware Debugger Plug-ins](ch12.md#1263-freertos-aware-debugger-plug-ins)

## [13 Troubleshooting](ch13.md#13-troubleshooting)
  + [13.1 Chapter Introduction and Scope](ch13.md#131-chapter-introduction-and-scope)
  + [13.2 Interrupt Priorities](ch13.md#132-interrupt-priorities)
  + [13.3 Stack Overflow](ch13.md#133-stack-overflow)
    + [13.3.1 The uxTaskGetStackHighWaterMark() API Function](ch13.md#1331-the-uxtaskgetstackhighwatermark-api-function)
    + [13.3.2 Run Time Stack Checking—Overview](ch13.md#1332-run-time-stack-checkingoverview)
    + [13.3.3 Run Time Stack Checking—Method 1](ch13.md#1333-run-time-stack-checkingmethod-1)
    + [13.3.4 Run Time Stack Checking—Method 2](ch13.md#1334-run-time-stack-checkingmethod-2)
    + [13.3.4 Run Time Stack Checking—Method 3](ch13.md#1334-run-time-stack-checkingmethod-3)
  + [13.4 Use of printf() and sprintf()](ch13.md#134-use-of-printf-and-sprintf)
    + [13.4.1 Printf-stdarg.c](ch13.md#1341-printf-stdargc)
  + [13.5 Other Common Sources of Error](ch13.md#135-other-common-sources-of-error)
    + [13.5.1 Symptom: Adding a simple task to a demo causes the demo to crash](ch13.md#1351-symptom-adding-a-simple-task-to-a-demo-causes-the-demo-to-crash)
    + [13.5.2 Symptom: Using an API function within an interrupt causes the application to crash](ch13.md#1352-symptom-using-an-api-function-within-an-interrupt-causes-the-application-to-crash)
    + [13.5.3 Symptom: Sometimes the application crashes within an interrupt service routine](ch13.md#1353-symptom-sometimes-the-application-crashes-within-an-interrupt-service-routine)
    + [13.5.4 Symptom: The scheduler crashes when attempting to start the first task](ch13.md#1354-symptom-the-scheduler-crashes-when-attempting-to-start-the-first-task)
    + [13.5.5 Symptom: Interrupts are unexpectedly left disabled, or critical sections do not nest correctly](ch13.md#1355-symptom-interrupts-are-unexpectedly-left-disabled-or-critical-sections-do-not-nest-correctly)
    + [13.5.6 Symptom: The application crashes even before the scheduler is started](ch13.md#1356-symptom-the-application-crashes-even-before-the-scheduler-is-started)
    + [13.5.7 Symptom: Calling API functions while the scheduler is suspended, or from inside a critical section, causes the application to crash](ch13.md#1357-symptom-calling-api-functions-while-the-scheduler-is-suspended-or-from-inside-a-critical-section-causes-the-application-to-crash)
  + [13.6 Additional Debugging Steps](ch13.md#136-additional-debugging-steps)


## Examples:
+ [Example 4.1 Creating tasks](ch04.md#example4.1)
+ [Example 4.2 Using the task parameter](ch04.md#example4.2)
+ [Example 4.3 Experimenting with priorities](ch04.md#example4.3)
+ [Example 4.4 Using the *Blocked* state to create a delay](ch04.md#example4.4)
+ [Example 4.5 Converting the example tasks to use vTaskDelayUntil()](ch04.md#example4.5)
+ [Example 4.6 Combining blocking and non-blocking tasks](ch04.md#example4.6)
+ [Example 4.7 Defining an idle task hook function](ch04.md#example4.7)
+ [Example 4.8 Deleting tasks](ch04.md#example4.8)
+ [Example 5.1 Blocking when receiving from a queue](ch05.md#example5.1)
+ [Example 5.2 Blocking when sending to a queue, and sending structures on a queue](ch05.md#example5.2)
+ [Example 5.3 Using a Queue Set](ch05.md#example5.3)
+ [Example 6.1 Creating one-shot and auto-reload timers](ch06.md#example6.1)
+ [Example 6.2 Using the callback function parameter and the software timer ID](ch06.md#example6.2)
+ [Example 6.3 Resetting a software timer](ch06.md#example6.3)
+ [Example 7.1 Using a binary semaphore to synchronize a task with an interrupt](ch07.md#example7.1)
+ [Example 7.2 Using a counting semaphore to synchronize a task with an interrupt](ch07.md#example7.2)
+ [Example 7.3 Centralized deferred interrupt processing](ch07.md#example7.3)
+ [Example 7.4 Sending and receiving on a queue from within an interrupt](ch07.md#example7.4)
+ [Example 8.1 Rewriting vPrintString() to use a semaphore](ch08.md#example8.1)
+ [Example 8.2 The alternative implementation for print task](ch08.md#example8.2)
+ [Example 9.1 Experimenting with event groups](ch09.md#example9.1)
+ [Example 9.2 Synchronizing tasks](ch09.md#example9.2)
+ [Example 10.1 Using a task notification in place of a semaphore, method 1](ch10.md#example10.1)
+ [Example 10.2 Using a task notification in place of a semaphore, method 2](ch10.md#example10.2)

## Figures:
+ [Figure 2.1 Top level directories within the FreeRTOS distribution](ch02.md#fig2.1)
+ [Figure 2.2 Core FreeRTOS source files within the FreeRTOS directory tree](ch02.md#fig2.2)
+ [Figure 2.3 Port specific source files within the FreeRTOS directory tree](ch02.md#fig2.3)
+ [Figure 2.4 The demo directory hierarchy](ch02.md#fig2.4)
+ [Figure 3.1 RAM being allocated from the heap\_1 array each time a task is created](ch03.md#fig3.1)
+ [Figure 3.2 RAM being allocated and freed from the heap\_2 array as tasks are created and deleted](ch03.md#fig3.2)
+ [Figure 3.3 RAM being allocated and freed from the heap\_4 array](ch03.md#fig3.3)
+ [Figure 3.4 Memory Map](ch03.md#fig3.4)
+ [Figure 4.1 Top level task states and transitions](ch04.md#fig4.1)
+ [Figure 4.2 The output produced when executing Example 4.1](ch04.md#fig4.2)
+ [Figure 4.3 The actual execution pattern of the two Example 4.1 tasks](ch04.md#fig4.3)
+ [Figure 4.4 The execution sequence expanded to show the tick interrupt executing](ch04.md#fig4.4)
+ [Figure 4.5 Running both tasks at different priorities](ch04.md#fig4.5)
+ [Figure 4.6 The execution pattern when one task has a higher priority than the...](ch04.md#fig4.6)
+ [Figure 4.7 Full task state machine](ch04.md#fig4.7)
+ [Figure 4.8 The output produced when Example 4.4 is executed](ch04.md#fig4.8)
+ [Figure 4.9 The execution sequence when the tasks use vTaskDelay() in place of the null loop](ch04.md#fig4.9)
+ [Figure 4.10 Bold lines indicate the state transitions performed by the tasks...](ch04.md#fig4.10)
+ [Figure 4.11 The output produced when Example 4.6 is executed](ch04.md#fig4.11)
+ [Figure 4.12 The execution pattern of Example 4.6](ch04.md#fig4.12)
+ [Figure 4.13 The output produced when Example 4.7 is executed](ch04.md#fig4.13)
+ [Figure 4.14 The sequence of task execution when running Example 4.8](ch04.md#fig4.14)
+ [Figure 4.15 The output produced when Example 4.8 is executed](ch04.md#fig4.15)
+ [Figure 4.16 The output produced when Example 4.9 is executed](ch04.md#fig4.16)
+ [Figure 4.17 The execution sequence for Example 4.9](ch04.md#fig4.17)
+ [Figure 4.18 Execution pattern highlighting task prioritization and preemption...](ch04.md#fig4.18)
+ [Figure 4.19 Execution pattern highlighting task prioritization and time slicing...](ch04.md#fig4.19)
+ [Figure 4.20 The execution pattern for the same scenario as shown in Figure 4.19...](ch04.md#fig4.20)
+ [Figure 4.21 Execution pattern that demonstrates how tasks of equal priority can...](ch04.md#fig4.21)
+ [Figure 4.22 Execution pattern demonstrating the behavior of the cooperative scheduler](ch04.md#fig4.22)
+ [Figure 5.1 An example sequence of writes to, and reads from a queue](ch05.md#fig5.1)
+ [Figure 5.2 The output produced when Example 5.1 is executed](ch05.md#fig5.2)
+ [Figure 5.3 The sequence of execution produced by Example 5.1](ch05.md#fig5.3)
+ [Figure 5.4 An example scenario where structures are sent on a queue](ch05.md#fig5.4)
+ [Figure 5.5 The output produced by Example 5.2](ch05.md#fig5.5)
+ [Figure 5.6 The sequence of execution produced by Example 5.2](ch05.md#fig5.6)
+ [Figure 5.7 The output produced when Example 5.3 is executed](ch05.md#fig5.7)
+ [Figure 6.1 The difference in behavior between one-shot and auto-reload software timers](ch06.md#fig6.1)
+ [Figure 6.2 Auto-reload software timer states and transitions](ch06.md#fig6.2)
+ [Figure 6.3 One-shot software timer states and transitions](ch06.md#fig6.3)
+ [Figure 6.4 The timer command queue being used by a software timer API function to communicate with the RTOS daemon task](ch06.md#fig6.4)
+ [Figure 6.5 The execution pattern when the priority of a task calling xTimerStart() is above the priority of the daemon task](ch06.md#fig6.5)
+ [Figure 6.6 The execution pattern when the priority of a task calling xTimerStart() is below the priority of the daemon task](ch06.md#fig6.6)
+ [Figure 6.7 The output produced when Example 6.1 is executed](ch06.md#fig6.7)
+ [Figure 6.8 The output produced when Example 6.2 is executed](ch06.md#fig6.8)
+ [Figure 6.9 Starting and resetting a software timer that has a period of 6 ticks](ch06.md#fig6.9)
+ [Figure 6.10 The output produced when Example 6.3 is executed](ch06.md#fig6.10)
+ [Figure 7.1 Completing interrupt processing in a high priority task](ch07.md#fig7.1)
+ [Figure 7.2 Using a binary semaphore to implement deferred interrupt processing](ch07.md#fig7.2)
+ [Figure 7.3 Using a binary semaphore to synchronize a task with an interrupt](ch07.md#fig7.3)
+ [Figure 7.4 The output produced when Example 7.1 is executed](ch07.md#fig7.4)
+ [Figure 7.5 The sequence of execution when Example 7.1 is executed](ch07.md#fig7.5)
+ [Figure 7.6 The scenario when one interrupt occurs before the task has finished processing the first event](ch07.md#fig7.6)
+ [Figure 7.7 The scenario when two interrupts occur before the task has finished processing the first event](ch07.md#fig7.7)
+ [Figure 7.8 Using a counting semaphore to ](ch07.md#fig7.8)
+ [Figure 7.9 The output produced when Example 7.2 is executed](ch07.md#fig7.9)
+ [Figure 7.10 The output produced when Example 7.3 is executed](ch07.md#fig7.10)
+ [Figure 7.11 The sequence of execution when Example 7.3 is executed](ch07.md#fig7.11)
+ [Figure 7.12 The output produced when Example 7.4 is executed](ch07.md#fig7.12)
+ [Figure 7.13 The sequence of execution produced by Example 7.4](ch07.md#fig7.13)
+ [Figure 7.14 Constants affecting interrupt nesting behavior](ch07.md#fig7.14)
+ [Figure 7.15 How a priority of binary 101 is stored by a Cortex-M microcontroller that implements four priority bits](ch07.md#fig7.15)
+ [Figure 8.1 Mutual exclusion implemented using a mutex](ch08.md#fig8.1)
+ [Figure 8.2 The output produced when Example 8.1 is executed](ch08.md#fig8.2)
+ [Figure 8.3 A possible sequence of execution for Example 8.1](ch08.md#fig8.3)
+ [Figure 8.4 A worst case priority inversion scenario](ch08.md#fig8.4)
+ [Figure 8.5 Priority inheritance minimizing the effect of priority inversion](ch08.md#fig8.5)
+ [Figure 8.6 A possible sequence of execution when tasks that have the same priority use the same mutex](ch08.md#fig8.6)
+ [Figure 8.7 A sequence of execution that could occur if two instances of the task shown by Listing 8.15 are created at the same priority](ch08.md#fig8.7)
+ [Figure 8.8 The output produced when Example 8.2 is executed](ch08.md#fig8.8)
+ [Figure 9.1 Event flag to bit number mapping in a variable of type EventBits\_t](ch09.md#fig9.1)
+ [Figure 9.2 An event group in which only bits 1, 4 and 7 are set, and all the other event flags are clear, making the event group](ch09.md#fig9.2)
+ [Figure 9.3 The output produced when Example 9.1 is executed with xWaitForAllBits set to pdFALSE](ch09.md#fig9.3)
+ [Figure 9.4 The output produced when Example 9.1 is executed with xWaitForAllBits set to pdTRUE](ch09.md#fig9.4)
+ [Figure 9.5 The output produced when Example 9.2 is executed](ch09.md#fig9.5)
+ [Figure 10.1 A communication object being used to send an event from one task to another](ch10.md#fig10.1)
+ [Figure 10.2 A task notification used to send an event directly from one task to another](ch10.md#fig10.2)
+ [Figure 10.3 The output produced when Example 7.1 is executed](ch10.md#fig10.3)
+ [Figure 10.4 The sequence of execution when Example 10.1 is executed](ch10.md#fig10.4)
+ [Figure 10.5 The output produced when Example 10.2 is executed](ch10.md#fig10.5)
+ [Figure 10.6 The communication paths from the application tasks to the cloud server, and back again](ch10.md#fig10.6)
+ [Figure 12.1 FreeRTOS+Trace includes more than 20 interconnected views](ch12.md#fig12.1)
+ [Figure 12.2 FreeRTOS+Trace main trace view - one of more than 20 interconnected trace views](ch12.md#fig12.2)
+ [Figure 12.3 FreeRTOS+Trace CPU load view - one of more than 20 interconnected trace views](ch12.md#fig12.3)
+ [Figure 12.4 FreeRTOS+Trace response time view - one of more than 20 interconnected trace views](ch12.md#fig12.4)
+ [Figure 12.5 FreeRTOS+Trace user event plot view - one of more than 20 interconnected trace views](ch12.md#fig12.5)
+ [Figure 12.6 FreeRTOS+Trace kernel object history view - one of more than 20 interconnected trace views](ch12.md#fig12.6)
+ [Figure 12.7 Example output generated by vTaskListTasks()](ch12.md#fig12.7)
+ [Figure 12.8 Example output generated by vTaskGetRunTimeStatistics()](ch12.md#fig12.8)

## Listings:
+ [Listing 2.1 The template for a new main() function](ch02.md#list2.1)
+ [Listing 3.1 The vPortDefineHeapRegions() API function prototype](ch03.md#list3.1)
+ [Listing 3.2 The HeapRegion\_t structure](ch03.md#list3.2)
+ [Listing 3.3 An array of HeapRegion\_t structures that together describe the 3 regions of RAM in their entirety](ch03.md#list3.3)
+ [Listing 3.4 An array of HeapRegion\_t structures that describe all of RAM2, all of RAM3, but only part of RAM1](ch03.md#list3.4)
+ [Listing 3.5 Using GCC syntax to declare the array that will be used by heap\_4, and place the array in a memory section named .my\_heap](ch03.md#list3.5)
+ [Listing 3.6 Using IAR syntax to declare the array that will be used by heap\_4, and place the array at the absolute address 0x20000000](ch03.md#list3.6)
+ [Listing 3.7 The xPortGetFreeHeapSize() API function prototype](ch03.md#list3.7)
+ [Listing 3.8 The xPortGetMinimumEverFreeHeapSize() API function prototype](ch03.md#list3.8)
+ [Listing 3.9 The vPortGetHeapStatus() API function prototype](ch03.md#list3.9)
+ [Listing 3.10 The HeapStatus\_t() structure](ch03.md#list3.10)
+ [Listing 3.11 The malloc failed hook function name and prototype](ch03.md#list3.11)
+ [Listing 3.12 Mapping the pvPortMallocStack() and vPortFreeStack() macros to an application defined memory allcator](ch03.md#list3.12)
+ [Listing 3.13 Typical implementation of vApplicationGetTimerTaskMemory](ch03.md#list3.13)
+ [Listing 3.14 Typical implementation of vApplicationGetIdleTaskMemory](ch03.md#list3.14)
+ [Listing 4.1 The task function prototype](ch04.md#list4.1)
+ [Listing 4.2 The structure of a typical task function](ch04.md#list4.2)
+ [Listing 4.3 The xTaskCreate() API function prototype](ch04.md#list4.3)
+ [Listing 4.4 Implementation of the first task used in Example 4.1](ch04.md#list4.4)
+ [Listing 4.5 Implementation of the second task used in Example 4.1](ch04.md#list4.5)
+ [Listing 4.6 Starting the Example 4.1 tasks](ch04.md#list4.6)
+ [Listing 4.7 Creating a task from within another task after the scheduler has started](ch04.md#list4.7)
+ [Listing 4.8 The single task function used to create two tasks in Example 4.2](ch04.md#list4.8)
+ [Listing 4.9 The main() function for Example 2](ch04.md#list4.9)
+ [Listing 4.10 Using the pdMS\_TO\_TICKS() macro to convert 200 milliseconds...](ch04.md#list4.10)
+ [Listing 4.11. Creating two tasks at different priorities](ch04.md#list4.11)
+ [Listing 4.12 The vTaskDelay() API function prototype](ch04.md#list4.12)
+ [Listing 4.13 The source code for the example task after replacing the null loop delay with a call...](ch04.md#list4.13)
+ [Listing 4.14 vTaskDelayUntil() API function prototype](ch04.md#list4.14)
+ [Listing 4.15 The implementation of the example task using vTaskDelayUntil()](ch04.md#list4.15)
+ [Listing 4.16 The continuous processing task used in Example 4.6](ch04.md#list4.16)
+ [Listing 4.17 The periodic task used in Example 4.6](ch04.md#list4.17)
+ [Listing 4.18 The idle task hook function name and prototype](ch04.md#list4.18)
+ [Listing 4.19 A very simple Idle hook function](ch04.md#list4.19)
+ [Listing 4.20 The source code for the example task now prints out the ulIdleCycleCount value](ch04.md#list4.20)
+ [Listing 4.21 The vTaskPrioritySet() API function prototype](ch04.md#list4.21)
+ [Listing 4.22 The uxTaskPriorityGet() API function prototype](ch04.md#list4.22)
+ [Listing 4.23 The implementation of Task 1 in Example 4.8](ch04.md#list4.23)
+ [Listing 4.24 The implementation of Task 2 in Example 4.8](ch04.md#list4.24)
+ [Listing 4.25 The implementation of main() for Example 4.8](ch04.md#list4.25)
+ [Listing 4.26 The vTaskDelete() API function prototype](ch04.md#list4.26)
+ [Listing 4.27 The implementation of main() for Example 4.9](ch04.md#list4.27)
+ [Listing 4.28 The implementation of Task 1 for Example 4.9](ch04.md#list4.28)
+ [Listing 4.29 The implementation of Task 2 for Example 4.9](ch04.md#list4.29)
+ [Listing 4.30 Function prototypes of the Thread Local Storage Pointer API functions](ch04.md#list4.30)
+ [Listing 5.1 The xQueueCreate() API function prototype](ch05.md#list5.1)
+ [Listing 5.2 The xQueueSendToFront() API function prototype](ch05.md#list5.2)
+ [Listing 5.3 The xQueueSendToBack() API function prototype](ch05.md#list5.3)
+ [Listing 5.4 The xQueueReceive() API function prototype](ch05.md#list5.4)
+ [Listing 5.5 The uxQueueMessagesWaiting() API function prototype](ch05.md#list5.5)
+ [Listing 5.6 Implementation of the sending task used in Example 5.1](ch05.md#list5.6)
+ [Listing 5.7  Implementation of the receiver task for Example 5.1](ch05.md#list5.7)
+ [Listing 5.8 The implementation of main() in Example 5.1](ch05.md#list5.8)
+ [Listing 5.9 The definition of the structure that is to be passed on a queue, plus the declaration of two variables for use by the example](ch05.md#list5.9)
+ [Listing 5.10 The implementation of the sending task for Example 5.2](ch05.md#list5.10)
+ [Listing 5.11 The definition of the receiving task for Example 5.2](ch05.md#list5.11)
+ [Listing 5.12 The implementation of main() for Example 5.2](ch05.md#list5.12)
+ [Listing 5.13 Creating a queue that holds pointers](ch05.md#list5.13)
+ [Listing 5.14 Using a queue to send a pointer to a buffer](ch05.md#list5.14)
+ [Listing 5.15 Using a queue to receive a pointer to a buffer](ch05.md#list5.15)
+ [Listing 5.16 The structure used to send events to the TCP/IP stack task in FreeRTOS+TCP](ch05.md#list5.16)
+ [Listing 5.17 Pseudo code showing how an IPStackEvent\_t structure is used to send data received from the network to the TCP/IP task](ch05.md#list5.17)
+ [Listing 5.18 Pseudo code showing how an IPStackEvent\_t structure is used to send the handle of a socket that is accepting a connection to the TCP/IP task](ch05.md#list5.18)
+ [Listing 5.19 Pseudo code showing how an IPStackEvent\_t structure is used to send a network down event to the TCP/IP task](ch05.md#list5.19)
+ [Listing 5.20 Pseudo code showing how an IPStackEvent\_t structure is received and processed](ch05.md#list5.20)
+ [Listing 5.21 The xQueueCreateSet() API function prototype](ch05.md#list5.21)
+ [Listing 5.22 The xQueueAddToSet() API function prototype](ch05.md#list5.22)
+ [Listing 5.23 The xQueueSelectFromSet() API function prototype](ch05.md#list5.23)
+ [Listing 5.24  Implementation of main() for Example 5.3](ch05.md#list5.24)
+ [Listing 5.25 The sending tasks used in Example 5.3](ch05.md#list5.25)
+ [Listing 5.26 The receive task used in Example 5.3](ch05.md#list5.26)
+ [Listing 5.27 Using a queue set that contains queues and semaphores](ch05.md#list5.27)
+ [Listing 5.28 A queue being created for use as a mailbox](ch05.md#list5.28)
+ [Listing 5.29 The xQueueOverwrite() API function prototype](ch05.md#list5.29)
+ [Listing 5.30 Using the xQueueOverwrite() API function](ch05.md#list5.30)
+ [Listing 5.31 The xQueuePeek() API function prototype](ch05.md#list5.31)
+ [Listing 5.32 Using the xQueuePeek() API function](ch05.md#list5.32)
+ [Listing 6.1 The software timer callback function prototype](ch06.md#list)
+ [Listing 6.2 The xTimerDelete() API function prototype](ch06.md#list6.2)
+ [Listing 6.3 The xTimerCreate() API function prototype](ch06.md#list6.3)
+ [Listing 6.4 The xTimerStart() API function prototype](ch06.md#list6.4)
+ [Listing 6.5 Creating and starting the timers used in Example 6.1](ch06.md#list6.5)
+ [Listing 6.6 The callback function used by the one-shot timer in Example 6.1](ch06.md#list6.5)
+ [Listing 6.7 The callback function used by the auto-reload timer in Example 6.1](ch06.md#list6.7)
+ [Listing 6.8 The vTimerSetTimerID() API function prototype](ch06.md#list6.8)
+ [Listing 6.9 The pvTimerGetTimerID() API function prototype](ch06.md#list6.9)
+ [Listing 6.10 Creating the timers used in Example 6.2](ch06.md#list6.10)
+ [Listing 6.11 The timer callback function used in Example 6.2](ch06.md#list6.11)
+ [Listing 6.12 The xTimerChangePeriod() API function prototype](ch06.md#list6.12)
+ [Listing 6.13 Using xTimerChangePeriod()](ch06.md#list6.13)
+ [Listing 6.14 The xTimerReset() API function prototype](ch06.md#list6.14)
+ [Listing 6.15 The callback function for the one-shot timer used in Example 6.3](ch06.md#list6.15)
+ [Listing 6.16 The task used to reset the software timer in Example 6.3](ch06.md#list6.16)
+ [Listing 7.1 The portEND\_SWITCHING\_ISR() macros](ch07.md#list7.1)
+ [Listing 7.2 The portYIELD\_FROM\_ISR() macros](ch07.md#list7.2)
+ [Listing 7.3 The xSemaphoreCreateBinary() API function prototype](ch07.md#list7.3)
+ [Listing 7.4 The xSemaphoreTake() API function prototype](ch07.md#list7.4)
+ [Listing 7.5 The xSemaphoreGiveFromISR() API function prototype](ch07.md#list)
+ [Listing 7.6 Implementation of the task that periodically generates a software interrupt in Example 7.1](ch07.md#list7.6)
+ [Listing 7.7 The implementation of the task to which the interrupt processing is deferred (the task that...](ch07.md#list7.7.)
+ [Listing 7.8 The ISR for the software interrupt used in Example 7.1](ch07.md#list7.8)
+ [Listing 7.9 The implementation of main() for Example 7.1](ch07.md#list7.9)
+ [Listing 7.10 The recommended structure of a deferred interrupt processing task, using a UART receive...](ch07.md#list7.10)
+ [Listing 7.11 The xSemaphoreCreateCounting() API function prototype](ch07.md#list7.11)
+ [Listing 7.12 The call to xSemaphoreCreateCounting() used to create the counting semaphore in Example 7.2](ch07.md#list7.12)
+ [Listing 7.13 The implementation of the interrupt service routine used by Example 7.2](ch07.md#list7.13)
+ [Listing 7.14 The xTimerPendFunctionCallFromISR() API function prototype](ch07.md#list7.14)
+ [Listing 7.15 The prototype to which a function passed in the xFunctionToPend parameter of xTimerPendFunctionCallFromISR()...](ch07.md#list7.15)
+ [Listing 7.16 The software interrupt handler used in Example 7.3](ch07.md#list7.16)
+ [Listing 7.17 The function that performs the processing necessitated by the interrupt in Example 7.3](ch07.md#list7.17)
+ [Listing 7.18 The implementation of main() for Example 7.3](ch07.md#list7.18)
+ [Listing 7.19 The xQueueSendToFrontFromISR() API function prototype](ch07.md#list7.19)
+ [Listing 7.20 The xQueueSendToBackFromISR() API function prototype](ch07.md#list7.20)
+ [Listing 7.21 The implementation of the task that writes to the queue in Example 7.4](ch07.md#list7.21)
+ [Listing 7.22 The implementation of the interrupt service routine used by Example 7.4](ch07.md#list7.22)
+ [Listing 7.23 The task that prints out the strings received from the interrupt service routine in Example 7.4](ch07.md#list7.23)
+ [Listing 7.24 The main() function for Example 7.4](ch07.md#list7.24)
+ [Listing 8.1 An example read, modify, write sequence](ch08.md#list8.1)
+ [Listing 8.2 An example of a reentrant function](ch08.md#list8.2)
+ [Listing 8.3 An example of a function that is not reentrant](ch08.md#list8.3)
+ [Listing 8.4 Using a critical section to guard access to a register](ch08.md#list8.4)
+ [Listing 8.5 A possible implementation of vPrintString()](ch08.md#list8.5)
+ [Listing 8.6 Using a critical section in an interrupt service routine](ch08.md#list8.6)
+ [Listing 8.7 The vTaskSuspendAll() API function prototype](ch08.md#list8.7)
+ [Listing 8.8 The xTaskResumeAll() API function prototype](ch08.md#list8.8)
+ [Listing 8.9 The implementation of vPrintString()](ch08.md#list8.9)
+ [Listing 8.10 The xSemaphoreCreateMutex() API function prototype](ch08.md#list8.10)
+ [Listing 8.11 The implementation of prvNewPrintString()](ch08.md#list8.11)
+ [Listing 8.12 The implementation of prvPrintTask() for Example 8.1](ch08.md#list8.12)
+ [Listing 8.13 The implementation of main() for Example 8.1](ch08.md#list8.13)
+ [Listing 8.14 Creating and using a recursive mutex](ch08.md#list8.14)
+ [Listing 8.15 A task that uses a mutex in a tight loop](ch08.md#list8.15)
+ [Listing 8.16 Ensuring tasks that use a mutex in a loop receive a more equal amount of processing time...](ch08.md#list8.16)
+ [Listing 8.17 The name and prototype for a tick hook function](ch08.md#list8.17)
+ [Listing 8.18 The gatekeeper task](ch08.md#list8.18)
+ [Listing 8.19 The print task implementation for Example 8.2](ch08.md#list8.19)
+ [Listing 8.20 The tick hook implementation](ch08.md#list8.20)
+ [Listing 8.21 The implementation of main() for Example 8.2](ch08.md#list8.21)
+ [Listing 9.1 The xEventGroupCreate() API function prototype](ch09.md#list9.1)
+ [Listing 9.2. The xEventGroupSetBits() API function prototype](ch09.md#list9.2)
+ [Listing 9.3 The xEventGroupSetBitsFromISR() API function prototype](ch09.md#list9.3)
+ [Listing 9.4 The xEventGroupWaitBits() API function prototype](ch09.md#list9.4)
+ [Listing 9.5 The xEventGroupGetStaticBuffer() API function prototype](ch09.md#list9.5)
+ [Listing 9.6 Event bit definitions used in Example 9.1](ch09.md#list9.6)
+ [Listing 9.7 The task that sets two bits in the event group in Example 9.1](ch09.md#list9.7)
+ [Listing 9.8 The ISR that sets bit 2 in the event group in Example 9.1](ch09.md#list9.8)
+ [Listing 9.9 The task that blocks to wait for event bits to become set in Example 9.1](ch09.md#list9.9)
+ [Listing 9.10 Creating the event group and tasks in Example 9.1](ch09.md#list9.10)
+ [Listing 9.11 Pseudo code for two tasks that synchronize with each other to ensure a shared TCP socket...](ch09.md#list9.11)
+ [Listing 9.12 The xEventGroupSync() API function prototype](ch09.md#list9.12)
+ [Listing 9.13 The implementation of the task used in Example 9.2](ch09.md#list9.13)
+ [Listing 9.14 The main() function used in Example 9.2](ch09.md#list9.14)
+ [Listing 10.1 The xTaskNotifyGive() API function prototype](ch10.md#list10.1)
+ [Listing 10.2 The vTaskNotifyGiveFromISR() API function prototype](ch10.md#list10.2)
+ [Listing 10.3 The ulTaskNotifyTake() API function prototype](ch10.md#list10.3)
+ [Listing 10.4 The implementation of the task to which the interrupt processing is deferred (the task that...](ch10.md#list10.4)
+ [Listing 10.5 The implementation of the interrupt service routine used in Example 10.1](ch10.md#list10.5)
+ [Listing 10.6 The implementation of the task to which the interrupt processing is deferred (the task...](ch10.md#list10.6)
+ [Listing 10.7 The implementation of the interrupt service routine used in Example 10.2](ch10.md#list10.7)
+ [Listing 10.8 Prototypes for the xTaskNotify() and xTaskNotifyFromISR() API functions](ch10.md#list10.8)
+ [Listing 10.9 The xTaskNotifyWait() API function prototype](ch10.md#list10.9)
+ [Listing 10.10 Pseudo code demonstrating how a binary semaphore can be used in a driver library transmit...](ch10.md#list10.10)
+ [Listing 10.11 Pseudo code demonstrating how a task notification can be used in a driver library transmit...](ch10.md#list10.11)
+ [Listing 10.12 Pseudo code demonstrating how a task notification can be used in a driver library receive...](ch10.md#list10.12)
+ [Listing 10.13 Pseudo code demonstrating how a task notification can be used to pass a value to a task](ch10.md#list10.13)
+ [Listing 10.14 The structure and data type sent on a queue to the server task](ch10.md#list10.14)
+ [Listing 10.15 The Implementation of the Cloud Read API Function](ch10.md#list10.15)
+ [Listing 10.16 The Server Task Processing a Read Request](ch10.md#list10.16)
+ [Listing 10.17 The Implementation of the Cloud Write API Function](ch10.md#list10.17)
+ [Listing 10.18 The Server Task Processing a Send Request](ch10.md#list10.18)
+ [Listing 11.1 The prototype for the portSUPPRESS\_TICKS\_AND\_SLEEP macro](ch11.md#list11.1)
+ [Listing 11.2 The vPortSuppressTicksAndSleep API function prototype](ch11.md#list11.2)
+ [Listing 11.3 The eTaskConfirmSleepModeStatus API function prototype](ch11.md#list11.3)
+ [Listing 11.4 The prototype for the configPRE\_SLEEP\_PROCESSING macro](ch11.md#list11.4)
+ [Listing 11.5 The prototype for the configPOST\_SLEEP\_PROCESSING macro](ch11.md#list11.5)
+ [Listing 11.6 An example of a user defined implementation of portSUPPRESS\_TICKS\_AND\_SLEEP()](ch11.md#list11.6)
+ [Listing 11.7 The vApplicationIdleHook API function prototype](ch11.md#list11.7)
+ [Listing 12.1 Using the standard C assert() macro to check pxMyPointer is not NULL](ch12.md#list12.1)
+ [Listing 12.2 A simple configASSERT() definition useful when executing under the control of a debugger](ch12.md#list12.2)
+ [Listing 12.3 A configASSERT() definition that records the source code line that failed an assertion](ch12.md#list12.3)
+ [Listing 12.4 The uxTaskGetSystemState() API function prototype](ch12.md#list12.4)
+ [Listing 12.5 The TaskStatus\_t structure](ch12.md#list12.5)
+ [Listing 12.6 The vTaskListTasks() API function prototype](ch12.md#list12.6)
+ [Listing 12.7 The vTaskList() API function prototype](ch12.md#list12.7)
+ [Listing 12.8 The vTaskGetRunTimeStatistics() API function prototype](ch12.md#list12.8)
+ [Listing 12.9 The vTaskGetRunTimeStats() API function prototype](ch12.md#list12.9)
+ [Listing 12.10 16-bit timer overflow interrupt handler used to count timer overflows](ch12.md#list12.10)
+ [Listing 12.11 Macros added to FreeRTOSConfig.h to enable the collection of run-time statistics](ch12.md#list12.11)
+ [Listing 12.12 The task that prints out the collected run-time statistics](ch12.md#list12.12)
+ [Listing 13.1 The uxTaskGetStackHighWaterMark() API function prototype](ch13.md#list13.1)
+ [Listing 13.2 The uxTaskGetStackHighWaterMark2() API function prototype](ch13.md#list13.2)
+ [Listing 13.3 The stack overflow hook function prototype](ch13.md#list13.3)

## Tables:
+ [Table 1 FreeRTOS source files to include in the project](ch02.md#tbl1)
+ [Table 2 TickType\_t data type and the configTICK\_TYPE\_WIDTH\_IN\_BITS configuration](ch02.md#tbl2)
+ [Table 3 Macro prefixes](ch02.md#tbl3)
+ [Table 4 Common macro definitions](ch02.md#tbl4)
+ [Table 5 The FreeRTOSConfig.h settings to configure the kernel scheduling algorithms](ch04.md#tbl5)
+ [Table 6 The Effect of the uxBitsToWaitFor and xWaitForAllBits Parameters](ch09.md#tbl6)
